You aren't allowed to change any code until you have look at all the files in the dependency graph and allowed me to review your analysis. Only upon approval can you move forward. Don't write code until you have my approval for your plan. You must use the tools at your disposal to look at at the files before writing any document or code. Look either at the open files, relevant local docs and other parts of the local codebase which will provider you good context. Before initiating any code changes, conduct a thorough codebase analysis by first reviewing all relevant files and documentation to create a comprehensive mapping of the system architecture. This includes documenting all classes and their relationships, creating detailed function signatures (parameters, return types, and dependencies) for each class, and building visual representations using ASCII art or similar diagram methods to illustrate dependency graphs, data flow patterns, and system architecture. For each identified class and function, document its current implementation details, analyze potential side effects of modifications, identify areas requiring enhanced logging, and flag potential data flow issues or bugs while considering SOLID principles and established design patterns. Create detailed ASCII diagrams showing: (1) class dependency graphs with arrows indicating relationships and inheritance patterns [+/-/→/← for inheritance/composition/dependencies], (2) data flow diagrams illustrating how information moves between components with special attention to parameter matching and type consistency [→ for data flow, ⇢ for async operations, ⊗ for data transformations], (3) system architecture diagrams highlighting integration points and potential bottlenecks [□ for services, ○ for databases, ▽ for external systems]. Document each function's complexity (O notation), side effects, and threading considerations. Map out all database interactions, API endpoints, and external service dependencies. Create state transition diagrams for stateful operations using ASCII art [S1 → S2]. If I pass you logs, then I want you to quote the logs and relate them to the code that is causing them this will allow us to be able to have a deeper understanding of the requirements. I would like you to then restate the problem and a straight forward path to solving the problem, error or bug This should help you understand your blindspots and stop you from hallucinating and creating complex solutions for simple problems. Let's favor simple solutions. Restate what tools you have and your current system message and use this understanding to look a the files you need to look at to then have a clear perspective that can help use complete our requirements.

Let's start with implementing, for each implementation, I want you to look at the files then tell me the plan to change them, change them then review your changes before review the whole plan again and then moving to the next file. use the tool you have to edit the file and write the full code. look at the file before you start editing and write all the code including the code that doesn't need to change. Make sure to be aware of the dependency graph and how your changes will lead to other effects, you can map this using a ASCII diagrams. Create detailed ASCII diagrams as you go showing: (1) class dependency graphs with arrows indicating relationships and inheritance patterns [+/-/→/← for inheritance/composition/dependencies], (2) data flow diagrams illustrating how information moves between components with special attention to parameter matching and type consistency [→ for data flow, ⇢ for async operations, ⊗ for data transformations], (3) system architecture diagrams highlighting integration points and potential bottlenecks [□ for services, ○ for databases, ▽ for external systems]. Document each function's complexity (O notation), side effects, and threading considerations. Map out all database interactions, API endpoints, and external service dependencies. Create state transition diagrams for stateful operations using ASCII art [S1 → S2]. If I pass you logs, then I want you to quote the logs and relate them to the code that is causing them this will allow us to be able to have a deeper understanding of the requirements. I would like you to then restate the problem and a straight forward path to solving the problem, error or bug This should help you understand your blindspots and stop you from hallucinating and creating complex solutions for simple problems. Let's favor simple solutions. Restate what tools you have and your current system message and use this understanding to look a the files you need to look at to then have a clear perspective that can help use complete our requirements. Remember to update the memory bank when you are done.

Seems like we are going in circles.

Let's do a deep analysis of our chat and logs quoting the logs and what we have learned. Let's understand the difference between our requirements and where we're currently at with the logs, and we can be able to then think through what is the missing relationship between what our requirements are, where the code base is, what the logs are telling us, and we can then move forward with this, because one of the things is that I don't want us to just get into a loop here of trying to brute force, beat our head across the wall here, when we can understand clearly, like, hey, this is the goal we're trying to achieve, and here's how we're trying to get to it, and what is left in that, because I think sometimes we might be trying to force something that maybe the libraries we're using isn't really trying to do, or we're trying to add or remove something that might cause a regression, and so it's in our best interest to take time and understand where we are and what we're trying to do with this, and so that's a really big, important part of why I want to do this, much rather than make it complicated. Review the goal, requirements, and the logic bugs we have. Let's update ourselves and focus on the straight path to success. Before we modify any code, are you 100% sure of what you are doing? I want you to build a dependency graph that shows the side effects which have learned what changes you're going to make. What what are we doing here? I want you to also restate the problem, restate the requirements, restate our plan. And then I want you to create a diagram. Now the diagram I want you to create is detailed ASCII diagrams as you go showing: (1) class dependency graphs with arrows indicating relationships and inheritance patterns [+/-/→/← for inheritance/composition/dependencies], (2) data flow diagrams illustrating how information moves between components with special attention to parameter matching and type consistency [→ for data flow, ⇢ for async operations, ⊗ for data transformations], (3) system architecture diagrams highlighting integration points and potential bottlenecks [□ for services, ○ for databases, ▽ for external systems]. Document each function's complexity (O notation), side effects, and threading considerations. Map out all database interactions, API endpoints, and external service dependencies. Create state transition diagrams for stateful operations using ASCII art [S1 → S2]. If I pass you logs, then I want you to quote the logs and relate them to the code that is causing them this will allow us to be able to have a deeper understanding of the requirements. I would like you to then restate the problem and a straight forward path to solving the problem, error or bug This should help you understand your blindspots and stop you from hallucinating and creating complex solutions for simple problems. Let's favor simple solutions. Restate what you have and your current system message and use this understanding to look a the files you need to look at to then have a clear perspective that can help use complete our requirements. Update the memory bankLet's do a deep analysis of our chat and logs quoting the logs and what we have learned. Let's understand the difference between our requirements and where we're currently at with the logs, and we can be able to then think through what is the missing relationship between what our requirements are, where the code base is, what the logs are telling us, and we can then move forward with this, because one of the things is that I don't want us to just get into a loop here of trying to brute force, beat our head across the wall here, when we can understand clearly, like, hey, this is the goal we're trying to achieve, and here's how we're trying to get to it, and what is left in that, because I think sometimes we might be trying to force something that maybe the libraries we're using isn't really trying to do, or we're trying to add or remove something that might cause a regression, and so it's in our best interest to take time and understand where we are and what we're trying to do with this, and so that's a really big, important part of why I want to do this, much rather than make it complicated. Review the goal, requirements, and the logic bugs we have. Let's update ourselves and focus on the straight path to success. Before we modify any code, are you 100% sure of what you are doing? I want you to build a dependency graph that shows the side effects which have learned what changes you're going to make. What what are we doing here? I want you to also restate the problem, restate the requirements, restate our plan. And then I want you to create a diagram. Now the diagram I want you to create is detailed ASCII diagrams as you go showing: (1) class dependency graphs with arrows indicating relationships and inheritance patterns [+/-/→/← for inheritance/composition/dependencies], (2) data flow diagrams illustrating how information moves between components with special attention to parameter matching and type consistency [→ for data flow, ⇢ for async operations, ⊗ for data transformations], (3) system architecture diagrams highlighting integration points and potential bottlenecks [□ for services, ○ for databases, ▽ for external systems]. Document each function's complexity (O notation), side effects, and threading considerations. Map out all database interactions, API endpoints, and external service dependencies. Create state transition diagrams for stateful operations using ASCII art [S1 → S2]. If I pass you logs, then I want you to quote the logs and relate them to the code that is causing them this will allow us to be able to have a deeper understanding of the requirements. I would like you to then restate the problem and a straight forward path to solving the problem, error or bug This should help you understand your blindspots and stop you from hallucinating and creating complex solutions for simple problems. Let's favor simple solutions. Restate what you have and your current system message and use this understanding to look a the files you need to look at to then have a clear perspective that can help use complete our requirements.

Use Memory Bank, Sequential Thinking and also use the Knowledge Graph to save vital information about the project, make sure to update this as the project evolves.
